<?php

namespace Omnipay\Wirecard\Message;

/**
 * Wirecard Abstract Request.
 */

use Omnipay\Common\Message\AbstractRequest as OmnipayAbstractRequest;
use Omnipay\Wirecard\CommonParametersTrait;
use Omnipay\Wirecard\Extend\ItemInterface;
use Omnipay\Common\ItemBag;

abstract class AbstractRequest extends OmnipayAbstractRequest
{
    // Shared gateway/message properties.
    use CommonParametersTrait;

    // Access to the constants as lists.
    use HasConstantListsTrait;

    /**
     * SINGLE - a single, one-off transaction, not recurring.
     * INITIAL - the first of a series of recurring transactions.
     * RECUR - the next in a series of recurring transactions.
     *
     * Note: "FINAL" was historically supported, but is no longer used.
     * Use RECUR in its place.
     */
    const TRANSACTION_IDENTIFIER_SINGLE     = 'SINGLE';
    const TRANSACTION_IDENTIFIER_INITIAL    = 'INITIAL';
    const TRANSACTION_IDENTIFIER_RECUR      = 'RECUR';

    /**
     * Supported payment types.
     */

    // The consumer may select one of the activated payment methods directly in Wirecard Checkout Page.
    // SELECT is only available for Wirecard Checkout Page.
    const PAYMENT_TYPE_SELECT = 'SELECT';
    // Bancontact/Mister Cash
    const PAYMENT_TYPE_BANCONTACT_MISTERCASH = 'BANCONTACT_MISTERCASH';
    // Credit Card, Maestro SecureCode
    const PAYMENT_TYPE_CCARD = 'CCARD';
    // Credit Card - Mail Order and Telephone Order
    const PAYMENT_TYPE_CCARD_MOTO = 'CCARD-MOTO';
    // eKonto
    const PAYMENT_TYPE_EKONTO = 'EKONTO';
    // ePay.bg
    const PAYMENT_TYPE_EPAY_BG = 'EPAY_BG';
    // eps-Ãœberweisung
    const PAYMENT_TYPE_EPS = 'EPS';
    // giropay
    const PAYMENT_TYPE_GIROPAY = 'GIROPAY';
    // iDEAL
    const PAYMENT_TYPE_IDL = 'IDL';
    // Installment: payolution or Installment: RatePAY
    const PAYMENT_TYPE_INSTALLMENT = 'INSTALLMENT';
    // Invoice: payolution, Invoice: RatePAY or Invoice by Wirecard
    const PAYMENT_TYPE_INVOICE = 'INVOICE';
    // Maestro SecureCode
    const PAYMENT_TYPE_MAESTRO = 'MAESTRO';
    // Masterpass
    const PAYMENT_TYPE_MASTERPASS = 'MASTERPASS';
    // moneta.ru
    const PAYMENT_TYPE_MONETA = 'MONETA';
    // Przelewy24
    const PAYMENT_TYPE_PRZELEWY24 = 'PRZELEWY24';
    // PayPal
    const PAYMENT_TYPE_PAYPAL = 'PAYPAL';
    // paybox
    const PAYMENT_TYPE_PBX = 'PBX';
    // POLi
    const PAYMENT_TYPE_POLI = 'POLI';
    // paysafecard
    const PAYMENT_TYPE_PSC = 'PSC';
    // @Quick
    const PAYMENT_TYPE_QUICK = 'QUICK';
    // SEPA Direct Debit
    const PAYMENT_TYPE_SEPA_DD = 'SEPA-DD';
    // Skrill Digital Wallet
    const PAYMENT_TYPE_SKRILLWALLET = 'SKRILLWALLET';
    // SOFORT
    const PAYMENT_TYPE_SOFORTUEBERWEISUNG = 'SOFORTUEBERWEISUNG';
    // TatraPay
    const PAYMENT_TYPE_TATRAPAY = 'TATRAPAY';
    // Trustly
    const PAYMENT_TYPE_TRUSTLY = 'TRUSTLY';
    // TrustPay
    const PAYMENT_TYPE_TRUSTPAY = 'TRUSTPAY';
    // My Voucher
    const PAYMENT_TYPE_VOUCHER = 'VOUCHER';

    /**
     * Return the fingerprint order string, based on the field
     * names (the keys) of the data to send.
     *
     * @param array $data The key/value data to send
     * @return string Comma-separated list of field names
     */
    public function getRequestFingerprintOrder($data)
    {
        $order = implode(',', array_keys($data));

        // Two additional fields will be included in the hash.
        $order .= ',requestFingerprintOrder';

        // If the secret is not already in the data (temporarily) then
        // add it to the end for the fingterprint hash.
        if (! array_key_exists('secret', $data)) {
            $order .= ',secret';
        }

        return $order;
    }

    /**
     * Calculates the fintgerprint hash of the data to send.
     * It is assumed that the requestFingerprintOrder field has already
     * been added to this data.
     *
     * @param array $data The key/value data to send
     * @return string Fingerprint hash
     */
    public function getRequestFingerprint($data)
    {
        $secret = $this->getSecret();

        $fields = implode('', array_values($data));

        // Add the secret to the string to hash, if it is not already in the
        // data.
        // It will never be sent with the data, but may be inserted just for the
        // signature creation.

        if (! array_key_exists('secret', $data)) {
            $fields .= $secret;
        }

        return hash_hmac('sha512', $fields, $secret);
    }

    /**
     * CHECKME: is this supplied by the merchant site, or generated by the
     * gateway? Or maybe optionally either?
     */
    public function setOrderNumber($value)
    {
        return $this->setParameter('orderNumber', $value);
    }

    public function getOrderNumber()
    {
        return $this->getParameter('orderNumber');
    }

    /**
     * The orderReference is sent right through to the financial
     * institution.
     * It is not necessarily the same as the transactionId, which
     * should only go as far as the gateway.
     */
    public function setOrderReference($value)
    {
        return $this->setParameter('orderReference', $value);
    }

    public function getOrderReference()
    {
        return $this->getParameter('orderReference');
    }

    /**
     * Text displayed on bank statement issued to your consumer by
     * the financial service provider.
     */
    public function setCustomerStatement($value)
    {
        return $this->setParameter('customerStatement', $value);
    }

    public function getCustomerStatement()
    {
        return $this->getParameter('customerStatement');
    }

    /**
     * Convert a collection of items to an array, as required to send to the gateway.
     * The fields are ordered for the signature generated when sending through
     * the backend API. The backend API has a strict signature field order. The front
     * end (Checkout Page and Seamless) don't care about the order, since they send the
     * order list along with the signature.
     */
    public function itemsAsArray(ItemBag $items)
    {
        $data = [];

        // The count of items in the basket.
        $data['basketItems'] = $items->count();

        $item_number = 0;
        foreach ($items->getIterator() as $item) {
            // Each item is sequentially numbered with a 1-based index.
            $item_number++;

            $prefix = 'basketItem' . $item_number;

            if ($item instanceof ItemInterface) {
                // The extended item class supports additional fields.
                $data[$prefix . 'ArticleNumber'] = $item->getArticleNumber() ?: $item_number;
                $data[$prefix . 'Quantity'] = $item->getQuantity();

                // The description is optional.
                if ($item->getDescription()) {
                    $data[$prefix . 'Description'] = $item->getDescription();
                }

                $data[$prefix . 'Name'] = $item->getName();

                // The image URL is is optional.
                if ($item->getImageUrl()) {
                    $data[$prefix . 'ImageUrl'] = $item->getImageUrl();
                }

                $data[$prefix . 'UnitGrossAmount'] = $item->getPrice();
                $data[$prefix . 'UnitNetAmount'] = $item->getNetAmount() ?: $item->getPrice();
                $data[$prefix . 'UnitTaxAmount'] = $item->getTaxAmount() ?: 0;
                $data[$prefix . 'UnitTaxRate'] = $item->getTaxRate() ?: 0;
            } else {
                // These are defaulted for the standard Omnipay Item, as
                // they are all required.
                $data[$prefix . 'ArticleNumber'] = $item_number;
                $data[$prefix . 'Quantity'] = $item->getQuantity();

                // The description is optional.
                if ($item->getDescription()) {
                    $data[$prefix . 'Description'] = $item->getDescription();
                }

                $data[$prefix . 'Name'] = $item->getName();
                $data[$prefix . 'UnitGrossAmount'] = $item->getPrice();
                $data[$prefix . 'UnitNetAmount'] = $item->getPrice();
                $data[$prefix . 'UnitTaxAmount'] = 0;
                $data[$prefix . 'UnitTaxRate'] = 0;
            }
        }

        return $data;
    }

    /**
     * Get the pending URL.
     *
     * @return string
     */
    public function getPendingUrl()
    {
        return $this->getParameter('pendingUrl');
    }

    /**
     * Sets the pending URL.
     *
     * @param string $value
     * @return AbstractRequest Provides a fluent interface
     */
    public function setPendingUrl($value)
    {
        return $this->setParameter('pendingUrl', $value);
    }

    /**
     * Return the full list of supported payment types.
     * Not all these may be actuvated for the account.
     *
     * @return array API values keyed by the constant name.
     */
    public function getPaymentTypes()
    {
        return $this->constantList('PAYMENT_TYPE');
    }

    public function getPaymentMethods()
    {
        return $this->getPaymentTypes();
    }

    /**
     * Get the redirect endpoint, if one is set.
     */
    public function getEndpoint()
    {
        return (property_exists($this, 'endpoint') ? $this->endpoint : null);
    }

    public function sendData($data)
    {
        return $this->createResponse($data);
    }

    /**
     * POST a HTTP message to the remote gateway.
     */
    public function sendHttp($data)
    {
        $headers = [];
        $httpResponse = $this->httpClient->request(
            'POST',
            $this->getEndpoint(),
            [
                'headers' => $headers,
            ],
            $data
        );

        // The response is a query string.
        // Parse it into an array.

        parse_str((string)$httpResponse->getBody(), $response_data);

        return $response_data;
    }

    /**
     *
     */
    public function setConsumerTaxIdentificationNumber($value)
    {
        return $this->setParameter('consumerTaxIdentificationNumber', $value);
    }

    public function getConsumerTaxIdentificationNumber()
    {
        return $this->getParameter('consumerTaxIdentificationNumber');
    }

    /**
     *
     */
    public function setConsumerDriversLicenseNumber($value)
    {
        return $this->setParameter('consumerDriversLicenseNumber', $value);
    }

    public function getConsumerDriversLicenseNumber()
    {
        return $this->getParameter('consumerDriversLicenseNumber');
    }

    /**
     *
     */
    public function setConsumerDriversLicenseState($value)
    {
        return $this->setParameter('consumerDriversLicenseState', $value);
    }

    public function getConsumerDriversLicenseState()
    {
        return $this->getParameter('consumerDriversLicenseState');
    }

    /**
     *
     */
    public function setConsumerDriversLicenseCountry($value)
    {
        return $this->setParameter('consumerDriversLicenseCountry', $value);
    }

    public function getConsumerDriversLicenseCountry()
    {
        return $this->getParameter('consumerDriversLicenseCountry');
    }

    /**
     * Consumer details.
     * Mainly optional, but may be required for some payment types.
     */
    public function getConsumerData()
    {
        $data = [];

        if ($this->getConsumerTaxIdentificationNumber()) {
            $data['consumerTaxIdentificationNumber'] = $this->getConsumerTaxIdentificationNumber();
        }

        if ($this->getConsumerDriversLicenseNumber()) {
            $data['consumerDriversLicenseNumber'] = $this->getConsumerDriversLicenseNumber();
        }

        // Alphabetic with a fixed length of 2 for US and CA, otherwise up to 40.
        if ($this->getConsumerDriversLicenseState()) {
            $data['consumerDriversLicenseState'] = $this->getConsumerDriversLicenseState();
        }

        // ISO 2-letter
        if ($this->getConsumerDriversLicenseCountry()) {
            $data['consumerDriversLicenseCountry'] = $this->getConsumerDriversLicenseCountry();
        }

        if ($card = $this->getCard()) {
            if ($card->getEmail()) {
                $data['consumerEmail'] = $card->getEmail();
            }

            // Foxed format YYYY-MM-DD
            if ($card->getBirthday()) {
                $data['consumerBirthDate'] = $card->getgetBirthday('Y-m-d');
            }

            // Billing details.

            if ($card->getBillingFirstName()) {
                $data['consumerBillingFirstname'] = $card->getBillingFirstName();
            }

            if ($card->getBillingLastName()) {
                $data['consumerBillingLastname'] = $card->getBillingLastName();
            }

            if ($card->getBillingAddress1()) {
                $data['consumerBillingAddress1'] = $card->getBillingAddress1();
            }

            if ($card->getBillingAddress2()) {
                $data['consumerBillingAddress2'] = $card->getBillingAddress2();
            }

            if ($card->getBillingCity()) {
                $data['consumerBillingCity'] = $card->getBillingCity();
            }

            // Fixed length 2-letter string. Possibly US-only?
            if ($card->getBillingState()) {
                $data['consumerBillingState'] = $card->getBillingState();
            }

            // Fixed length 2-letter string. Possibly US-only?
            if ($card->getBillingCountry()) {
                $data['consumerBillingCountry'] = $card->getBillingCountry();
            }

            // Fixed length 2-letter string. Possibly US-only?
            if ($card->getBillingPostcode()) {
                $data['consumerBillingZipCode'] = $card->getBillingPostcode();
            }

            if ($card->getBillingPhone()) {
                $data['consumerBillingPhone'] = $card->getBillingPhone();
            }

            if ($card->getBillingFax()) {
                $data['consumerBillingFax'] = $card->getBillingFax();
            }

            // Shipping details.

            if ($card->getShippingFirstName()) {
                $data['consumerShippingFirstname'] = $card->getShippingFirstName();
            }

            if ($card->getShippingLastName()) {
                $data['consumerShippingLastname'] = $card->getShippingLastName();
            }

            if ($card->getShippingAddress1()) {
                $data['consumerShippingAddress1'] = $card->getShippingAddress1();
            }

            if ($card->getShippingAddress2()) {
                $data['consumerShippingAddress2'] = $card->getShippingAddress2();
            }

            if ($card->getShippingCity()) {
                $data['consumerShippingCity'] = $card->getShippingCity();
            }

            // Fixed length 2-letter string. Possibly US-only?
            if ($card->getShippingState()) {
                $data['consumerShippingState'] = $card->getShippingState();
            }

            // Fixed length 2-letter string. Possibly US-only?
            if ($card->getShippingCountry()) {
                $data['consumerShippingCountry'] = $card->getShippingCountry();
            }

            // Fixed length 2-letter string. Possibly US-only?
            if ($card->getShippingPostcode()) {
                $data['consumerShippingZipCode'] = $card->getShippingPostcode();
            }

            if ($card->getShippingPhone()) {
                $data['consumerShippingPhone'] = $card->getShippingPhone();
            }

            if ($card->getShippingFax()) {
                $data['consumerShippingFax'] = $card->getShippingFax();
            }
        }

        return $data;
    }

    /**
     * Create a new Response message given the raw data in the response.
     */
    abstract protected function createResponse($data);
}
